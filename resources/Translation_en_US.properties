supportedInstructions=Supported Instructions
mnemonic=Mnemonic
instruction=Instruction
meaning=Meaning
binaryCode=Binary code
console=Console
code=Code
control=Control
memory=Memory
datapath=Datapath
register=Register
value=Value
clock=Clock
subClock=Sub-clock
address=Address
searchByAddress=Search memory by address
controlMemory=Control Memory
file=File
new=New
load=Load
save=Save
examples=Examples
simpleAdder=Simple adder
nthFibNum=N-th Fibonacci number
exit=Exit
execute=Execute
run=Run F1
nextSubClk=Next sub-clock cycle F2
nextClk=Next clock cycle F3
help=Help
about=About
newFile=New file Ctrl+N
loadFile=Load file Ctrl+L
saveFile=Save file Ctrl+S
runCode=Run code F1
language=Language:
successful-assemble=Code assembled successfully
line-num-err-message=Error on line number 
unknown-instr-mnemonic=, unknown instruction mnemonic
missing-arg=, missing argument
unknown-label=, unknown label name
arg-out-of-bounds=, argument out of bounds
invalid-arg=, invalid argument
too-many-args=, too many arguments
no-code-err=Error blank code area
recurring-label=, recurring label name
error=Error
invalid-new-val=Invalid new value!
valid-range=valid range is
immutable-reg=register is immutable
confirmation=Confirmation
new-code-file=Are you sure you want to create a new code file
curr-progress=Current progress will be lost
instr-fetch=Fetching instruction...
instr-exec=Executing instruction
decimal=Decimal
binary=Binary
LODD=Load directly
STOD=Store directly
ADDD=Add directly
SUBD=Subtract directly
JPOS=Jump if (ac)>=0
JZER=Jump if (ac)==0
JUMP=Unconditional jump
LOCO=Load constant
LODL=Load locally
STOL=Store locally
ADDL=Add locally
SUBL=Subtract locally
JNEG=Jump if (ac)<0
JNZE=Jump if (ac)!=0
CALL=Procedure call
PSHI=Push to stack indirectly
POPI=Pop from stack indirectly
PUSH=Push to stack
POP=Pop from stack
RETN=Return from procedure
SWAP=Swap contents of ac and sp
INSP=Increment sp
DESP=decrement sp
credits=Credits
icons-download=All icons are downloaded from
icon-authors=Icon authors are listed below:
run-button=- run button, next sub-clock button, next clock button:
load-file-button=- load file button:
new-file-button=- new file button:
save-button=- save button:
language-circles=- language circles
back=Back
jumpToEnd=Jump to end
endProgram=End execution F4
program-exec-stop=Program execution aborted
load-code-file=Are you sure you want to load a new code file
load-code-example=Are you sure you want to load an example
end-program-exec-warn=Are you sure you want to abort current program execution
firstNToStack=First n numbers to stack
app-description=MIC-1 Simulator is an interactive simulator for the MIC-1 cpu, described in Andrew S. Tanenbaum's textbook Structured Computer Organization. The application is primarily intended to be used by the students of the Faculty of Electrical Engineering in Sarajevo, but everyone is welcome to use it. The idea is that the user, while using the application, gains better understanding of the principles behind the MIC-1 cpu. The user is able to write code using the supported instruction set, to run the code and to see it being executed through the cpu cycles. While the instructions are being executed the user can keep track of the memory state, control memory state, cpu registers and the different cpu components.
how-to=How to
app-use=Use the application
useful-tips=Useful tips
get-involved=Get involved
key-shortcuts=Key shortcuts
report-bugs=Report bugs
help-development=Help develop
icons=Icons
icon-credits=All icons are downloaded from\n - https://www.flaticon.com/\n\nIcon authors are listed below\n\nIcon run, Icon next sub-cycle, Icon next cycle, Gmail icon\n - https://www.flaticon.com/authors/pixel-perfect\n\nIcon load file\n - https://www.flaticon.com/authors/iconixar\n\nIcon new file\n - https://www.flaticon.com/authors/smashicons\n\nIcon end program\n - https://www.flaticon.com/authors/alfredo-hernandez\n\nFlag icons, Icon save file, Facebook icon, GitHub icon\n - https://www.flaticon.com/authors/freepik\n\nApplication icon\n - https://www.flaticon.com/authors/chattapat\n\nLinked in icon\n - https://www.flaticon.com/authors/riajulislam
report-bugs-text=Feel free to report bugs. To do so you can either:\n - Open an issue on GitHub at https://github.com/abecirovic3/MIC-1-Simulator/issues\n - Report the bug via email abecirovic3@etf.unsa.ba
help-development-text=Want to contribute to app development?\n\nTo make your contribution follow these steps:\n - Create a fork of the base project\n - Clone your forked project to your local environment\n - Create a new branch\n - Make your changes\n - Push the changes to your repository\n - On your GitHub repository click on 'Compare & pull request' button\n - Leave a comment and create your pull request\n\nNote, the branch naming convention is feature-[name] for new features, fix-[name] for bug fixes
shortcuts-text=Make sure to use the keyboard shortcuts.\nTo run your code press F1\nTo execute a sub-cycle press F2\nTo execute a cycle press F3\nTo end program execution press F4\nTo create a new file press Ctrl+N\nTo load a file press Ctrl+L\nTo save a file press Ctrl+S\nTo switch between tabs press Ctrl+TAB
close=Close
contact=Contact
contact-me=Contact me
use-app-text=The main goal of the application is to enable the user to execute cpu instructions through cpu cycles.\n\nThe application is devided in four tabs: code, control, memory and datapath. Now I will cover each of them.\n\nCode tab\nIn the code tab you can see a table containing information about the cpu instruction set. You can make use of the table when writing your code (Comments are single line only and start with the character ;). To the left of the table there is a code area in which you can write code. Under the table there is a console field which will indicate whether the assembly process was successful or not. As said earlier you can write your own code, or you can make use of the examples provided by the application. If you want to load an example, go to the File menu, choose Examples, and then choose your desired example to load. Yet another way to get code loaded is to load a file which contains proper code. You can load your file either by pressing Ctrl+L, or you can again navigate to the file menu and choose Load file. Note that the supported file types are .txt and .mic1 files. .mic1 is just an extension which you can give your files to distinguish them from other textual files. After you have loaded your code, one way or the other, you can then run it by pressing F1, clicking on the green play button, or navigating to the Execute menu and choosing the Run option. If the code is correct it will be assembled, and you will see in the console a success message. If on the other side the code has issues you will see an error message in the console. Fix the error and run the code again. To execute the code you can choose to run a sub-cycle or one entire cycle. To run a sub-cycle press F2, click on the single right arrow button, or navigate to the Execute menu and choose the Run sub-cycle option. To run a cycle press F3, click on the double right arrow button, or navigate to the Execute menu and choose the Run cycle option. To stop program execution and return to the initial state press F4, click on the red square button, or navigate to the Execute menu and choose the Stop execution option. To save your code you can press Ctrl+S, click on the floppy disk button, or navigate to the File menu and choose Save file option. There you have it. In this section we covered how to write or load code, run, execute and save it.\n\nControl tab\nThe control tab represents the CPU control unit. We can see a code area with human-readable code which represents the CPU microcode. To the right of the code area there is a table which represents the control memory containing the micro-instructions in binary form. While you are executing your program, in the control tab, you can keep track of the currently active micro-instruction, which is highlighted green in the code area.\n\nMemory tab\nThe memory tab represents the main memory. In the memory tab we can see a search field and a table. The table represents the 4096 memory addresses, and since it is a big table we provided the search field to make things easier when searching the table. To search the table enter an address value between 0 and 4095 and click on the search button. The corresponding value will be loaded in the field right to the button, and the table will be scrolled to the desired address and the corresponding row will be highlighted. You can also double-click on each cell in the Value column to set a particular value to the desired memory address. Keep in mind that the provided value must be a 16-bit integer. Also note that the assembled code will be stored in memory starting with the address 0. So if your code has, for instance 3 instructions, addresses 0, 1 and 2 will then contain your instructions. This means that changing values at these addresses will lead to unpredictable behavior.\n\nDatapath tab\nWe can fairly say that the datapath tab is the main application tab. The main idea behind this tab is to enable the user to keep track of the CPU registers, the MBR, MAR, MIR and MPC registers, currently executing sub-cycle and cycle, and also to keep track of the data flow. To keep track of the data flow hover over the individual components with your mouse, and you will see the state of that particular component. Note that component state is only valid and to be seen when that component was active. Different components are active in different sub-cycles. If the component was active in a particular sub-cycle it will be colored. For instance the ALU will be colored in green after the third sub-cycle is done, indicating that the ALU was active in that sub-cycle. Note that this sort of data flow representation isn't true to the real world model data flow, considering clock pulses etc., but it shows how the data is transferred from one component to the other. The CPU registers table is also editable. Double-click on a cell in the Value column and set the desired value. Note that some registers are immutable, and that you must provide a valid value (what is a valid value depends on the register itself). One neat feature in the datapath tab is the instruction-status bar found in the bottom. It shows if an instruction is being fetched or executed which tells you what the CPU is currently processing. This was a short explanation of the datapath tab, feel free to experiment more yourself and find other important features.\n\nThese were the application tabs. One more interesting feature is that you can change the number format, in which the values found in the memory and datapath tab, are represented. In the upper right corner, to the left of the language select, there is a dropdown menu. Select your desired number format and the UI representation will change.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n